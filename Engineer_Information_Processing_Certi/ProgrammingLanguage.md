# 프로그래밍 언어 활용

## C
### 문자열 처리함수
+ strcmp(s1, s2): 문자열을 비교하여 같다면 0을 반환하고, 다르면 음수를 반환하는 함수
### 연산문제
```
#include ＜stdio.h＞
    int main(int argc, char *argv[]) {
    int a=5, b=3, c=12;
    int t1, t2, t3;
    t1=a && b;
    t2=a || b;
    t3=!c;
    printf("%d", t1+t2+t3);
    return 0;
}
```
+ 📌 C언어에서 정수는 0이면 거짓이고 0이 아니면 참이다.
+ 따라서 a, b, c는 모두 참이다.
+ t1은 모두 참이므로 참인 1의 값을 갖는다.
+ t2는 모두 참이므로 하나라도 참이기 때문에 참인 1의 값을 갖는다.
+ t3는 참의 역인 거짓으로 0의 값을 갖는다.
<br>

```
#include ＜stdio.h＞
struct st{
    int a;
    int c[10];
};

int main (int argc, char *argv[]) {
    int i＝0;
    struct st ob1;
    struct st ob2;
    ob1.a＝0;
    ob2.a＝0;
    for(i＝0; i＜10; i++) {
        ob1.c[i]＝i;
        ob2.c[i]＝ob1.c[i]＋i;
    }
    for(i＝0; i＜10; i＝i＋2) {
        ob1.a＝ob1.a＋ob1.c[i];
        ob2.a＝ob2.a＋ob2.c[i];
    }
    printf("%d", ob1.a ob2.a);
    return 0;
}
```
+ 📌 두 번째 for문은 2씩 증가함에 유의하자
+ 첫 번째 for문에서 ob1.c는 0~9, ob2.c는 ob1.c보다 각각 2배의 값을 갖게 된다.
+ 두 번째 for문에서 ob1.a = 2+4+6+8 = 20, ob1.b = 4+8+12+16 = 40 이므로 전체 합은 60이 된다.
+ ❓ 마지막에 덧셈 표시가 별도로 없는데 더하는 것인가..?
<br>

```
#include＜stdio.h＞
#include＜stdlib.h＞
int main(int argc, char *argv[] ) {
  int arr[2][3]＝{1,2,3,4,5,6};
  int (*p)[3]＝NULL;
  p＝arr;
  printf("%d, ", *(p[0]+1)+*(p[1]+2));
  printf("%d", *(*(p+1)+0)+*(*(p+1)+1));
  return 0;
}
// 8,9
```
+ [해설](https://www.youtube.com/watch?v=AQFNQjfsLmc&ab_channel=Hikcoding)
+ 처음 선언된 arr에는 첫 배열에 1,2,3이 들어가고, 두 번째는 4,5,6을 갖는 이차배열이다.
+ 여기서 ```*p```는 임의의 int 배열(3칸)을 가리키는 포인터인데, arr과 매칭하므로써 arr의 첫 인덱스부터 순서대로 1,2,3을 가리키게 된다.
+ 그럼 ```*p[1]```의 표현은 3칸을 한 묶음으로 보기 때문에 4를 첫 인덱스로 가리키게 된다.
+ ```*p+1```의 경우는 포인터에서 내부 배열 중 첫 인덱스 다음 값을 말한다.
+ ```printf("%d, ", *(p[0]+1)+*(p[1]+2));```
  + 여기서 ```*(p[0]+1)```부분은 포인터 위치 변경은 없고 내부 이동이므로 2의 주소를 참조한다.
  + 여기서 ```*(p[1]+2)```부분은 포인터 위치 변경으로 한 단계 내려간 4을 가리키는데 내부 2칸 이동으로 6의 주소를 참조한다.
  + 즉, 더해서 8이 된다.
+ ```printf("%d", *(*(p+1)+0)+*(*(p+1)+1))```
  + 위와 동일하게 ```*(*(p+1)+0)``` 부분은 포인터 1단계 이동 후 내부 이동은 없으므로 4의 주소를 참조한다.
  + ```*(*(p+1)+1))``` 부분은 포인터 1단계 이동 후 내부 이동 1칸이므로 5의 주소를 참조한다.
  + 즉, 더해서 9가 된다.

<br><br>
## Python
### 데이터 타입
> 자료형, 문자열과 리스트, 튜플, 딕셔너리, 세트
+ [튜플](https://wikidocs.net/71)
  + 시퀀스(Sequence) 데이터 타입에 해당하며 다양한 데이터 타입들을 주어진 순서에 따라 저장할 수 있으나 저장된 내용을 변경할 수 없는 것
  + 내용을 변경하려고 하는 경우 리스트처럼 해당 부분의 내용을 바꿀 수 없어 나누어 변경, 저장해야 한다.
### 연산문제
+ if, elif, else

<br><br>
## JAVA
### 예외(Exception)
+ 

<br><br>
## OSI 7계층
> 응용 > 표현 > 세션 > 전송 > 네트워크 > 데이터링크 > 물리
### 데이터링크 계층
+ 프로토콜: 📌 HDLC, PPP, LLC
### 응용 계층
+ 프로토콜: HTTP

<br><br>
## 네트워크 계층 프로토콜
### IP 프로토콜
+ 📌 Header Length는 IP 프로토콜의 헤더 길이를 32비트 워드 단위로 표시한다. 
+ 📌 Packet Length는 IP 헤더를 포함한 패킷 전체의 길이를 나타내며 최대 크기는 232－1비트이다. 
+ Time To Live는 송신 호스트가 패킷을 전송하기 전 네트워크에서 생존할 수 있는 시간을 지정한 것이다.
+ Version Number는 IP 프로토콜의 버전번호를 나타낸다.
+ 📌 주로 주소를 지정하고, 경로를 설정하는 기능을 한다.
+ 📌 체크섬(Checksum) 기능 제공
  + 체크섬 필드를 '0'으로 하여 계산한다.
  + IP, UDP, TCP의 헤더 포맷을 보면 checksum을 위한 공간이 존재한다. 이 부분은 패킷의 헤더가 전송되는 도중 데이터가 변조되거나 깨지는 경우를 확인하기 위해 사용된다.
  + 체크섬: 중복 검사의 형태로 송신된 자료의 무결성을 보호하는 방법
+ 📌 패킷을 분할, 병합하는 기능을 수행하기도 한다. 
+ 📌 비연결형 서비스를 제공한다. 
+ 📌 Best Effort 원칙에 따른 전송 기능을 제공한다.
#### [IP 주소체계](https://xn--3e0bx5euxnjje69i70af08bea817g.xn--3e0b707e/jsp/resources/ipv6Info.jsp)
+ IPv4
  + 표시방법: 8비트씩 4부분 10진수
  + IPv4는 호스트 주소를 자동으로 설정하며 유니캐스트(Unicast)를 지원한다.
  + IPv4는 클래스별로 네트워크와 호스트 주소의 길이가 다르다.
+ IPv6
  + 표시방법: 16비트씩 8부분 16진수
  + IPv4와 달리 IPv6의 패킷 헤더는 임의 길이일 수 있다.(확장헤더)
  + IPv6는 주소 자동 설정(Auto Configuration) 기능을 통해 손쉽게 이용자의 단말을 네트워크에 접속시킬 수 있다. 
  + 2<sup>128</sup>개의 주소를 표현할 수 있다. 
  + 등급별, 서비스별로 패킷을 구분할 수 있어 품질보장이 용이하다. 
  + 확장기능을 통해 보안기능을 제공한다.


<br><br>
## 전송 계층 프로토콜
### TCP 프로토콜, 연결지향
+ 흐름제어(Flow Control), 오류제어(Error Control), 혼잡제어(Congestion Control)
+ 양방향 연결 서비스 제공
+ 가상 회선 연결(Virtual Circuit Connection)형태의 서비스를 제공한다
### UDP 프로토콜, 비연결지향
+ 단순한 헤더 구조로 오버헤드가 적다. 전송속도가 빠르다.
+ 📌 데이터의 순차적 전송을 보장하지 않는다.
+ 신뢰성 있는 TCP와는 달리 흐름제어(Flow Control), 오류제어(Error Control), 혼잡제어(Congestion Control) 등을 수행하지 않는다.
+ 한 번의 패킷 송수신으로 완료되는 서비스에 많이 사용된다.

<br><br>
## 라우팅 프로토콜
### RIP 라우팅 프로토콜
+ 라우팅 정보 관리를 위해 경유하는 라우터의 대수(Hop Count)에 따라 최단 경로를 동적으로 결정하는 거리 벡터 알고리즘을 사용
+ 📌 경로 선택 메트릭은 홉 카운트(Hop Count)이다.
+ 라우팅 프로토콜을 IGP와 EGP로 분류했을 때 EGP에 해당한다.
  + IGP 내부 경로 설정을 위한 프로토콜
  + EGP 외부에서 내부로 집입할 수 있는 경로 설정을 위한 프로토콜
+ 📌 최단 경로 탐색에 Bellman-Ford 알고리즘을 사용한다. 
+ 📌 각 라우터는 이웃 라우터들로부터 수신한 정보를 이용하여 라우팅 표를 갱신한다
+ 최적의 경로가 아닌 경우도 발생
+ 최대 15개까지만 거침
#### 홉 카운트(Hop Count)
+ 출발지와 목적지 사이에 위치한 경로의 한 부분
+ 홉 자체는 라우터라고 보면 된다.

<br><br>
## 프로세스 스케줄링
### 선점 스케줄링
> SRT(Shortest Remaining Time), 라운드로빈 스케줄링, 다단계 큐(Mulit-level Queue), 다단계 피드백 큐 스케줄링
### 비선점 스케줄링
> FCFS(First come first service), SJF(Shortest job first), 우선 순위, HRN(Highest response next)
+ 이미 할당된 CPU를 다른 프로세스가 강제로 빼앗아 사용할 수 없는 스케줄링 기법
#### HRN 스케줄링
+ 📌 최소 작업 우선(SJF) 기법의 약점을 보완한 비선점 스케줄링 기법
+ 우선순위 = (대기시간+서비스시간)/서비스시간
#### SJF 스케줄링
+ 큐 프로세스 중 수행시간이 짧은 것을 먼저 수행하는 방법으로 평균 대기시간을 감소시킨다.
#### 우선순위 스케줄링
+ 우선순위 순으로 수행하며, 응답속도 증가
+ 동적으로 우선순위를 부여할 경우, 구현이 복잡하고 오버헤드가 많다.

<br><br>
## 운영체제
### UNIX
+ 하나 이상의 작업에 대하여 백그라운드에서 수행이가능하다. 
+ 📌 다중 사용자, 다중 작업을 지원한다.
+ 📌 트리 구조의 파일 시스템을 갖는다.
+ 이식성이 높으며 장치 간의 호환성이 높다.
+ 대부분 C언어로 되어 있으며, 이식성이 높다.
#### 구성
+ 하드웨어 > 커널 > 쉘 > 유틸리티 > 사용자

<br><br>
## 응집도(Cohesion)
> 기능적 > 순차적 > 통신적 > 절차적 > 일시적 > 논리적 > 우연적
+ 응집도는 모듈의 독립성을 나타내는 개념으로, 모듈 내부 구성요소 간 연관 정도

<br><br>
## 결합도(Coupling)
> 내용 > 공통 > 외부 > 제어 > 스탬프 > 자료
+ 결합도는 모듈 내부가 아닌 외부의 모듈과의 연관도 또는 모듈 간의 상호의존성을 나타내는 정도
### 내용결합도
  + 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 참조하는 경우

<br><br>
## 페이지 교체 알고리즘
### LRU 페이지 교체 알고리즘
+ 최근에 가장 오랫동안 사용하지 않은 페이지를 교체하는 기법
+ 📌 https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=botemi11&logNo=220062848209

1 3 3 1 4 // 2 3 1 2 4 // 4 4 3 2 2 // 3 1 1 1 3
1 3 1 1 1 // 1 3 2 4 4 // 1 4 2 2 4 // 3 1 2 2 3



